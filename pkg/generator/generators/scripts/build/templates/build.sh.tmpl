#!/bin/bash
# build.sh - Service build script
# This script is used to build the service and prepare deployment artifacts.
#
# Environment Variables (automatically set by Dockerfile):
#   - BUILD_OUTPUT_DIR: Absolute path to build output directory (e.g., /opt/dist)
#   - PROJECT_ROOT: Absolute path to project root (e.g., /opt)
#
# For local builds, these variables will be calculated automatically if not set.

set -e # Exit on error

SERVICE_NAME={{ .SERVICE_NAME }}

# ============================================
# Build Output Directory Configuration
# ============================================
#
# In Docker build: BUILD_OUTPUT_DIR=/opt/dist, PROJECT_ROOT=/opt (set by Dockerfile)
#
# DO NOT hardcode "dist" anywhere in your scripts - always use ${BUILD_OUTPUT_DIR}

# Check required environment variables
if [ -z "${PROJECT_ROOT}" ]; then
	echo "ERROR: PROJECT_ROOT environment variable is not set!"
	echo ""
	echo "This script must be run in a Docker container where PROJECT_ROOT is set by Dockerfile."
	echo "Expected: PROJECT_ROOT=/opt (or your configured project root)"
	echo ""
	echo "If you're seeing this error:"
	echo "  1. Make sure you're building with Docker (not running the script directly)"
	echo "  2. Check that your Dockerfile sets: ENV PROJECT_ROOT=/opt"
	echo "  3. Verify the Dockerfile is using the correct base image"
	exit 1
fi

# Change to project root directory
cd "${PROJECT_ROOT}"

# If BUILD_OUTPUT_DIR not set, use PROJECT_ROOT/dist as default
BUILD_OUTPUT_DIR="${BUILD_OUTPUT_DIR:-${PROJECT_ROOT}/dist}"

# Set SERVICE_ROOT (project root, same as PROJECT_ROOT in container context)
# In container: PROJECT_ROOT=/opt, SERVICE_ROOT=/opt
# This allows build commands to reference ${SERVICE_ROOT}
SERVICE_ROOT="${PROJECT_ROOT}"

export BUILD_OUTPUT_DIR
export PROJECT_ROOT
export SERVICE_NAME
export SERVICE_ROOT

echo "Project root: ${PROJECT_ROOT}"
echo "Service root: ${SERVICE_ROOT}"
echo "Build output directory: ${BUILD_OUTPUT_DIR}"


# ============================================
# Standardized Multi-language Build Support
# ============================================
echo "========================================="
echo "TCS Service Build System"
echo "Service: ${SERVICE_NAME}"
echo "========================================="

# Create output directories
mkdir -p ${BUILD_OUTPUT_DIR}/bin ${BUILD_OUTPUT_DIR}/conf

# ============================================
# Execute pre-build commands
# ============================================
{{- if .PRE_BUILD_COMMAND }}
echo "Executing pre-build commands..."
{{ .PRE_BUILD_COMMAND }}
[ $? -ne 0 ] && echo "ERROR: Pre-build commands failed" && exit 1
echo "Pre-build completed successfully"
{{- end }}

# ============================================
# Execute build commands
# ============================================
echo "Executing build commands..."
# Ensure we're in the project root directory before building
cd ${PROJECT_ROOT}
{{ .BUILD_COMMAND }}
[ $? -ne 0 ] && echo "ERROR: Build commands failed" && exit 1
echo "Build completed successfully"

# ============================================
# Execute post-build commands
# ============================================
{{- if .POST_BUILD_COMMAND }}
echo "Executing post-build commands..."
{{ .POST_BUILD_COMMAND }}
[ $? -ne 0 ] && echo "ERROR: Post-build commands failed" && exit 1
echo "Post-build completed successfully"
{{- end }}

# ============================================
# Deploy artifacts
# ============================================
target_path={{ .DEPLOY_DIR }}/${SERVICE_NAME}
# create service dir
mkdir -p ${target_path}

# Copy build artifacts from BUILD_OUTPUT_DIR directory
if [ ! -d "${BUILD_OUTPUT_DIR}" ]; then
	echo "ERROR: ${BUILD_OUTPUT_DIR}/ directory not found!"
	echo ""
	echo "The build commands must output artifacts to the ${BUILD_OUTPUT_DIR}/ directory."
	echo "Please ensure build commands create and populate ${BUILD_OUTPUT_DIR}/"
	exit 1
fi

echo "Copying artifacts from ${BUILD_OUTPUT_DIR}/ to ${target_path}/"
cp -rf ${BUILD_OUTPUT_DIR}/* ${target_path}/

[ $? -ne 0 ] && exit

# ============================================
# Setup TCE environment and install plugins
# ============================================
{{- if .PLUGINS }}
# 创建插件根目录
mkdir -p {{ .PLUGIN_ROOT_DIR }}

{{- range .PLUGINS }}
# ============================================
# Install plugin: {{ .Name }}
# ============================================
PLUGIN_NAME="{{ .Name }}"
PLUGIN_DOWNLOAD_URL="{{ .DownloadURL }}"
PLUGIN_INSTALL_DIR="{{ .InstallDir }}"
PLUGIN_WORK_DIR="{{ $.PLUGIN_ROOT_DIR }}/{{ .Name }}"

echo "Installing plugin: ${PLUGIN_NAME}"
echo "Download URL: ${PLUGIN_DOWNLOAD_URL}"
echo "Install directory: ${PLUGIN_INSTALL_DIR}"
echo "Plugin work directory: ${PLUGIN_WORK_DIR}"

# 创建插件工作目录
mkdir -p ${PLUGIN_WORK_DIR}

{{- if .InstallCommand }}
# Use custom install command from configuration
echo "Using custom install command..."
{{ .InstallCommand }}
{{- else }}
# Default install command: download and execute script
echo "Using default install command..."
set -o pipefail # Enable pipefail to catch errors in pipe
if ! curl -fsSL ${PLUGIN_DOWNLOAD_URL} | bash -es ${PLUGIN_WORK_DIR}; then
	echo "ERROR: Failed to download or execute plugin script"
	echo "URL: ${PLUGIN_DOWNLOAD_URL}"
	echo "Target directory: ${PLUGIN_WORK_DIR}"
	exit 1
fi
{{- end }}

if [ $? -eq 0 ]; then
	echo "Plugin {{ .Name }} downloaded to work directory successfully"
else
	echo "ERROR: Plugin {{ .Name }} download failed"
	exit 1
fi

{{- if .RuntimeEnv }}
# ============================================
# Setup runtime environment variables for {{ .Name }}
# ============================================
echo "Setting up runtime environment variables for {{ .Name }}..."

# 创建插件环境变量文件
ENV_FILE="${PLUGIN_WORK_DIR}/.env"
cat > ${ENV_FILE} << EOF
{{- range .RuntimeEnv }}
export {{ .Name }}="{{ .Value }}"
{{- end }}
EOF

echo "Environment variables written to ${ENV_FILE}"
{{- end }}

echo "Plugin {{ .Name }} setup completed"
echo ""
{{- end }}

# ============================================
# Generate unified plugin install script
# ============================================
echo "Generating plugin install script..."
INSTALL_SCRIPT="{{ .PLUGIN_ROOT_DIR }}/install.sh"
cat > ${INSTALL_SCRIPT} << 'INSTALL_EOF'
#!/bin/bash
# Plugin installation script
# This script copies plugins from /plugins/<name> to their install directories
set -e

echo "========================================="
echo "Installing Plugins"
echo "========================================="

{{- range .PLUGINS }}
# Install plugin: {{ .Name }}
echo "Installing {{ .Name }} to {{ .InstallDir }}..."
mkdir -p {{ .InstallDir }}
if [ -d "{{ $.PLUGIN_ROOT_DIR }}/{{ .Name }}" ]; then
	cp -rf {{ $.PLUGIN_ROOT_DIR }}/{{ .Name }}/* {{ .InstallDir }}/
	echo "✓ {{ .Name }} installed successfully"
else
	echo "ERROR: Plugin directory {{ $.PLUGIN_ROOT_DIR }}/{{ .Name }} not found"
	exit 1
fi

{{- if .RuntimeEnv }}
# Setup runtime environment for {{ .Name }}
ENV_FILE="{{ .InstallDir }}/.env"
cat > ${ENV_FILE} << ENV_EOF
{{- range .RuntimeEnv }}
export {{ .Name }}="{{ .Value }}"
{{- end }}
ENV_EOF
echo "✓ Environment variables written to ${ENV_FILE}"
{{- end }}

{{- end }}

echo "========================================="
echo "All plugins installed successfully"
echo "========================================="
INSTALL_EOF

chmod +x ${INSTALL_SCRIPT}
echo "✓ Generated ${INSTALL_SCRIPT}"
{{- end }}


# ============================================
# Generate runtime scripts
# ============================================
echo "Generating runtime scripts..."

# 复制运行时脚本到服务目录
SERVICE_DIR="{{ .SERVICE_ROOT }}"
# Use container path (absolute path in container) instead of host relative path
CI_CONTAINER_DIR="{{ .CI_CONTAINER_DIR }}"

mkdir -p ${SERVICE_DIR}

if [ -f "${CI_CONTAINER_DIR}/entrypoint.sh" ]; then
	cp -f ${CI_CONTAINER_DIR}/entrypoint.sh ${SERVICE_DIR}/entrypoint.sh
	chmod +x ${SERVICE_DIR}/entrypoint.sh
	echo "✓ Generated ${SERVICE_DIR}/entrypoint.sh"
fi

if [ -f "${CI_CONTAINER_DIR}/healthchk.sh" ]; then
	cp -f ${CI_CONTAINER_DIR}/healthchk.sh ${SERVICE_DIR}/healthcheck.sh
	chmod +x ${SERVICE_DIR}/healthcheck.sh
	echo "✓ Generated ${SERVICE_DIR}/healthcheck.sh"
fi

echo "Done!"
