# Define build arguments - only set once
{{- if eq .ARCH "amd64" }}
ARG TLINUX_BASE_IMAGE_X86  
ARG TLINUX_TAG_X86
ARG BUILDER_IMAGE_X86
{{- else }}
ARG TLINUX_BASE_IMAGE_ARM  
ARG TLINUX_TAG_ARM
ARG BUILDER_IMAGE_ARM
{{- end }}
ARG DEPLOY_DIR={{ .DEPLOY_DIR }}

# ============================================
# Stage 1: deps - Install dependencies
# ============================================
{{- if eq .ARCH "amd64" }}
FROM ${BUILDER_IMAGE_X86} AS deps
{{- else }}
FROM ${BUILDER_IMAGE_ARM} AS deps
{{- end }}

# Set build output directory (shared between deps_install.sh and build.sh)
ENV BUILD_OUTPUT_DIR=/opt/dist
ENV PROJECT_ROOT=/opt

WORKDIR /opt

# Copy dependency files only (for caching)
# Copy only dependency manifest files to leverage Docker cache
# When these files don't change, Docker will reuse the cached dependency layer
# Detected dependency files for: {{ .LANGUAGE }}
{{- range .DEPENDENCY_FILES }}
COPY {{ . }} ./
{{- end }}

# Copy build scripts needed for dependency installation
# Note: CI_SCRIPT_DIR is relative to project root, will be at /opt/{{ .CI_SCRIPT_DIR }} in container
COPY {{ .CI_SCRIPT_DIR }}/{{ .DEPS_INSTALL_SCRIPT }} {{ .CI_SCRIPT_DIR }}/

# Install dependencies (cacheable if deps files unchanged)
# This layer will be cached if dependency files haven't changed
# Only source code changes won't invalidate this cache layer
RUN sh -xe {{ .DEPS_INSTALL_SCRIPT_CONTAINER_PATH }}

{{- if .HAS_PLUGINS }}
# ============================================
# Stage 2: plugin-builder - Build plugins independently
# ============================================
FROM deps AS plugin-builder

ENV PROJECT_ROOT=/opt
WORKDIR /opt

# Copy plugin build script
COPY {{ .CI_SCRIPT_DIR }}/{{ .PLUGIN_BUILD_SCRIPT }} {{ .CI_SCRIPT_DIR }}/

# Build plugins (output to /plugins directory)
# This stage is independent from service build, changes to plugins won't trigger service rebuild
RUN sh -xe {{ .PLUGIN_BUILD_SCRIPT_CONTAINER_PATH }}
{{- end }}

# ============================================
# Stage 3: builder - Build service
# ============================================
FROM deps AS builder

# Use ARG value as ENV in builder stage
ARG DEPLOY_DIR
ENV DEPLOY_DIR=${DEPLOY_DIR}

# Copy all source code
# Copy remaining source code after dependencies are installed
# This ensures dependency layer cache is preserved when only source code changes
COPY . /opt/

# Build the service (without plugin build logic)
# Build using already installed dependencies
RUN sh -xe {{ .BUILD_SCRIPT_CONTAINER_PATH }}

# ============================================
# Stage 4: runtime - Runtime image
# ============================================
{{- if eq .ARCH "amd64" }}
FROM ${TLINUX_BASE_IMAGE_X86}:${TLINUX_TAG_X86}
{{- else }}
FROM ${TLINUX_BASE_IMAGE_ARM}:${TLINUX_TAG_ARM}
{{- end }}

# Use ARG value in runtime stage
ARG DEPLOY_DIR

# Copy runtime preparation script
COPY {{ .CI_SCRIPT_DIR }}/{{ .RT_PREPARE_SCRIPT }} /tmp/{{ .RT_PREPARE_SCRIPT }}

# Install runtime dependencies
RUN sh -xe /tmp/{{ .RT_PREPARE_SCRIPT }} && rm -f /tmp/{{ .RT_PREPARE_SCRIPT }}

# Copy built artifacts from builder stage
COPY --from=builder ${DEPLOY_DIR} ${DEPLOY_DIR}

{{- if .HAS_PLUGINS }}
# Copy plugins from plugin-builder stage (independent from service build)
COPY --from=plugin-builder /plugins /plugins

# Install plugins to their respective directories
RUN sh -xe /plugins/install.sh
{{- end }}

# Set working directory to service directory
WORKDIR ${DEPLOY_DIR}/{{ .SERVICE_NAME }}

# Set entrypoint (use service-specific entrypoint script)
ENTRYPOINT ["./entrypoint.sh"]
