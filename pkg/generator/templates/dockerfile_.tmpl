# Define build arguments - only set once
{{- if eq .ARCH "amd64" }}
ARG TLINUX_BASE_IMAGE_X86  
ARG TLINUX_TAG_X86
ARG BUILDER_IMAGE_X86
{{- else }}
ARG TLINUX_BASE_IMAGE_ARM  
ARG TLINUX_TAG_ARM
ARG BUILDER_IMAGE_ARM
{{- end }}
ARG DEPLOY_DIR={{ .DEPLOY_DIR }}

# Builder stage
{{- if eq .ARCH "amd64" }}
FROM ${BUILDER_IMAGE_X86} AS builder
{{- else }}
FROM ${BUILDER_IMAGE_ARM} AS builder
{{- end }}

# Use ARG value as ENV in builder stage
ARG DEPLOY_DIR
ENV DEPLOY_DIR=${DEPLOY_DIR}

# Set build output directory (shared between deps_install.sh and build.sh)
ENV BUILD_OUTPUT_DIR=/opt/dist
ENV PROJECT_ROOT=/opt

WORKDIR /opt

# ============================================
# Layer 1: Copy dependency files only (for caching)
# ============================================
# Copy only dependency manifest files to leverage Docker cache
# When these files don't change, Docker will reuse the cached dependency layer
# Detected dependency files for: {{ .LANGUAGE }}
{{- range .DEPENDENCY_FILES }}
COPY {{ . }} ./
{{- end }}

# Copy build scripts needed for dependency installation
# Note: CI_SCRIPT_DIR is relative to project root, will be at /opt/{{ .CI_SCRIPT_DIR }} in container
COPY {{ .CI_SCRIPT_DIR }}/{{ .DEPS_INSTALL_SCRIPT }} {{ .CI_SCRIPT_DIR }}/

# ============================================
# Layer 2: Install dependencies (cacheable if deps files unchanged)
# ============================================
# This layer will be cached if dependency files haven't changed
# Only source code changes won't invalidate this cache layer
RUN sh -xe {{ .DEPS_INSTALL_SCRIPT_CONTAINER_PATH }}

# ============================================
# Layer 3: Copy all source code
# ============================================
# Copy remaining source code after dependencies are installed
# This ensures dependency layer cache is preserved when only source code changes
COPY . /opt/

# ============================================
# Layer 4: Build the service
# ============================================
# Build using already installed dependencies
RUN sh -xe {{ .BUILD_SCRIPT_CONTAINER_PATH }}

# Runtime stage
{{- if eq .ARCH "amd64" }}
FROM ${TLINUX_BASE_IMAGE_X86}:${TLINUX_TAG_X86}
{{- else }}
FROM ${TLINUX_BASE_IMAGE_ARM}:${TLINUX_TAG_ARM}
{{- end }}

# Use ARG value in runtime stage
ARG DEPLOY_DIR

# Copy runtime preparation script
COPY {{ .CI_SCRIPT_DIR }}/{{ .RT_PREPARE_SCRIPT }} /tmp/{{ .RT_PREPARE_SCRIPT }}

# Install runtime dependencies
RUN sh -xe /tmp/{{ .RT_PREPARE_SCRIPT }} && rm -f /tmp/{{ .RT_PREPARE_SCRIPT }}

# Copy built artifacts from builder stage
COPY --from=builder ${DEPLOY_DIR} ${DEPLOY_DIR}

{{- if .HAS_PLUGINS }}
# ============================================
# Copy plugins from builder stage
# ============================================
# Copy all plugins from /plugins directory
COPY --from=builder /plugins /plugins

# Install plugins to their respective directories
RUN sh -xe /plugins/install.sh
{{- end }}

# Set working directory to service directory
WORKDIR ${DEPLOY_DIR}/{{ .SERVICE_NAME }}

# Set entrypoint (use service-specific entrypoint script)
ENTRYPOINT ["./entrypoint.sh"]
