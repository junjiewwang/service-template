# ============================================
# TCS Service Configuration
# Version: 2.0
# ============================================

# ============================================
# 基础服务信息
# ============================================
service:
  name: example-service
  description: "Example Service"

  # 服务端口配置（支持多端口）
  # 可用变量：SERVICE_PORT（主端口，取第一个端口）
  ports:
  - name: http
    port: 8080
    protocol: TCP
    expose: true
    description: "HTTP API port"

  - name: metrics
    port: 9090
    protocol: TCP
    expose: false
    description: "Prometheus metrics"

  deploy_dir: /usr/local/services

# ============================================
# 语言和版本配置
# ============================================
language:
  type: go # go | python | nodejs | java | rust
  version: "1.23"
  config:
    # Go 特定配置
    goproxy: "https://goproxy.cn,direct"
    gosumdb: "sum.golang.org"
    # Python 特定配置（示例）
    # pip_index_url: "https://mirrors.tencent.com/pypi/simple"
    # pip_trusted_host: "mirrors.tencent.com"

    # Node.js 特定配置（示例）
    # npm_registry: "https://mirrors.tencent.com/npm/"

    # ============================================
    # 构建配置
    # ============================================
build:
  dependency_files:
    auto_detect: true # 自动检测依赖文件

  # 构建基础镜像（按架构）
  builder_image:
    amd64: "mirrors.tencent.com/tcs-infra/tceforqci_x86_go23:v1.0.0"
    arm64: "mirrors.tencent.com/tcs-infra/tceforqci_arm_go23:v1.0.0"

  # 运行时基础镜像（按架构）
  runtime_image:
    amd64: "mirrors.tencent.com/tencentos/tencentos3-minimal:latest"
    arm64: "mirrors.tencent.com/tencentos/tencentos3-minimal:latest"

  # 构建阶段系统依赖
  # 工具会自动检测包管理器（apt-get/yum/apk/dnf/zypper）
  system_dependencies:
    packages:
    - git
    - make
    - gcc

  # 构建命令（三阶段）
  # 可用变量：
  #   ${SERVICE_NAME}       - 服务名称
  #   ${SERVICE_ROOT}       - 服务根目录
  #   ${BUILD_OUTPUT_DIR}   - 构建输出目录
  #   ${DEPLOY_DIR}         - 部署目录
  #   ${GOARCH}             - Go 架构（仅 Go）
  #   ${GOOS}               - Go 操作系统（仅 Go）
  commands:
    pre_build: |
      echo "Pre-build stage"
      go version

    build: |
      cd ${SERVICE_ROOT}
      CGO_ENABLED=0 go build -ldflags="-s -w" -o ${BUILD_OUTPUT_DIR}/bin/${SERVICE_NAME} ./cmd/server
      cp -r configs ${BUILD_OUTPUT_DIR}/
      cp -r scripts ${BUILD_OUTPUT_DIR}/

    post_build: |
      echo "Post-build completed"

  output_dir: dist

# ============================================
# 插件配置
# ============================================
# 插件处理流程：
# 1. 在 build.sh 脚本中将插件下载到 /plugins/<plugin_name> 目录
# 2. 为每个插件生成 .env 文件存储运行时环境变量
# 3. 生成统一的 /plugins/install.sh 脚本
# 4. 在 Dockerfile 中从 builder 镜像复制 /plugins 目录到 runtime 镜像
# 5. 在 Dockerfile 中执行 install.sh，将插件从 /plugins/<name> 复制到 install_dir
# 6. 在 entrypoint.sh 中加载各插件的环境变量
# ============================================
plugins:
- name: selfMonitor
  description: "TCE Self Monitor Tool"
  download_url: "https://mirrors.tencent.com/repository/generic/selfMonitor/download_tool.sh"
  install_dir: /tce

  # 安装命令（在 builder 阶段执行）
  # 注意：install_command 应该将插件下载到 ${PLUGIN_WORK_DIR}（即 /plugins/selfMonitor）
  # 而不是直接安装到 ${PLUGIN_INSTALL_DIR}（最终安装目录在 runtime 阶段由 install.sh 处理）
  #
  # 可用变量：
  #   ${PLUGIN_NAME}           - 插件名称
  #   ${PLUGIN_DESCRIPTION}    - 插件描述
  #   ${PLUGIN_DOWNLOAD_URL}   - 下载地址
  #   ${PLUGIN_WORK_DIR}       - 插件工作目录（/plugins/<name>）
  #   ${PLUGIN_INSTALL_DIR}    - 最终安装目录（runtime 阶段）
  #   ${SERVICE_NAME}          - 服务名称
  #   ${SERVICE_ROOT}          - 服务根目录
  #   ${BUILD_OUTPUT_DIR}      - 构建输出目录
  install_command: |
    echo "Downloading ${PLUGIN_NAME} to ${PLUGIN_WORK_DIR}..."
    curl -fsSL "${PLUGIN_DOWNLOAD_URL}" | bash -s "${PLUGIN_WORK_DIR}"
    echo "${PLUGIN_NAME} downloaded successfully"

  # 运行时环境变量（会写入到 .env 文件）
  # 这些环境变量会在 entrypoint.sh 中加载，使其在服务运行时生效
  # 注意：value 中可以使用 ${PLUGIN_INSTALL_DIR} 变量，会在生成时替换为实际路径
  runtime_env:
  - name: TCESTAURY_TOOL_PATH
    value: ${PLUGIN_INSTALL_DIR}
  - name: TCESTAURY_CONFIG_PATH
    value: ${PLUGIN_INSTALL_DIR}/config

  required: true

# ============================================
# 运行时配置
# ============================================
# 运行时脚本生成：
# 1. build.sh 会生成 entrypoint.sh 和 healthcheck.sh 脚本
# 2. 这些脚本会被放置在服务目录中（${SERVICE_ROOT}）
# 3. entrypoint.sh 负责加载插件环境变量并启动服务
# 4. healthcheck.sh 负责服务健康检查
# ============================================
runtime:
  # 运行时系统依赖
  # 工具会自动检测包管理器
  system_dependencies:
    packages:
    - ca-certificates
    - tzdata

  # 健康检查配置
  # 工具会根据 type 自动生成 healthcheck.sh 脚本
  #
  # 生成逻辑：
  # 1. 当 enabled=false 时，生成默认的进程检查脚本
  # 2. 当 enabled=true 且 type=custom 时：
  #    - 如果提供了 custom_script，则使用 custom_script 的内容
  #    - 如果未提供 custom_script，则生成默认的进程检查脚本
  # 3. 当 enabled=true 且 type 为其他类型（http/tcp/exec）时，生成默认的进程检查脚本
  #
  healthcheck:
    enabled: true
    type: http # http | tcp | exec | custom

    # HTTP 健康检查（当 type=http 时使用）
    # 注意：此配置主要用于 Docker Compose 的 healthcheck 配置
    # 实际的 healthchk.sh 脚本仍使用默认的进程检查逻辑
    http:
      path: /health
      port: 8080
      timeout: 3

    # 自定义健康检查脚本（当 type=custom 时使用）
    # 重要：只有当 type=custom 且提供了 custom_script 时，才会替换默认的 healthchk.sh 内容
    #
    # 可用变量：
    #   ${SERVICE_NAME}       - 服务名称
    #   ${SERVICE_PORT}       - 主服务端口
    #   ${SERVICE_ROOT}       - 服务根目录
    #   ${CONFIG_DIR}         - 配置目录
    #   ${SERVICE_BIN_DIR}    - 二进制目录
    #   ${DEPLOY_DIR}         - 部署目录
    custom_script: |
      #!/bin/sh
      # Custom health check logic
      curl -f http://localhost:${SERVICE_PORT}/health || exit 1

  # 启动配置
  # 工具会根据此配置生成 entrypoint.sh 脚本
  startup:
    # 启动命令（会被写入 entrypoint.sh）
    # 可用变量：
    #   ${SERVICE_NAME}       - 服务名称
    #   ${SERVICE_PORT}       - 主服务端口
    #   ${SERVICE_ROOT}       - 服务根目录
    #   ${CONFIG_DIR}         - 配置目录
    #   ${SERVICE_BIN_DIR}    - 二进制目录
    #   ${DEPLOY_DIR}         - 部署目录
    command: |
      #!/bin/sh
      set -e
      cd ${SERVICE_ROOT}
      exec ./bin/${SERVICE_NAME}

    # 环境变量（会在 entrypoint.sh 中设置）
    env:
    - name: GO_ENV
      value: production
    - name: LOG_LEVEL
      value: info

# ============================================
# 本地开发和测试配置
# ============================================
local_dev:
  # Docker Compose 配置
  compose:
    # 资源限制
    resources:
      limits:
        cpus: "0.5"
        memory: 1G
      reservations:
        cpus: "0.25"
        memory: 512M

    # 卷挂载配置（唯一配置源）
    # 工具会自动：
    #   1. 生成 compose.yaml 的 volumes 配置
    #   2. 通过 kompose 转换为 K8s ConfigMap/PVC
    #   3. 自动识别配置文件目录并生成 ConfigMap
    #
    # 支持的变量替换：
    #   ${SERVICE_NAME}       - 服务名称
    #   ${SERVICE_ROOT}       - 服务根目录（${DEPLOY_DIR}/${SERVICE_NAME}）
    #   ${PLUGIN_INSTALL_DIR} - 插件安装目录（从 plugins 配置中获取）
    volumes:
    - source: ./bk-ci/tcs/build/config.yaml
      target: ${SERVICE_ROOT}/config.yaml
      type: bind
      description: "Service config"

    - source: ./bk-ci/tcs/build/sdk.json
      target: ${PLUGIN_INSTALL_DIR}/config/sdk.json
      type: bind
      description: "TCE SDK config"
    # 数据卷示例
    # - source: app-data
    #   target: /data
    #   type: volume
    #   description: "Application data"

    # 健康检查配置（Docker Compose 格式）
    healthcheck:
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

    # 标签配置
    labels:
      kompose.image-pull-policy: "IfNotPresent"
      reloader.stakater.com/auto: "true"

  # Kubernetes 本地部署配置
  kubernetes:
    enabled: true
    namespace: default
    output_dir: k8s-manifests

    # 卷类型配置（kompose 转换时使用）
    volume_type: configMap # configMap | persistentVolumeClaim | emptyDir | hostPath

    # ConfigMap 配置（自动推导）
    configmap:
      auto_detect: true # 自动从 compose.volumes 推导
      # name: custom-config             # 可选：自定义 ConfigMap 名称

      # 部署等待配置
    wait:
      enabled: true
      timeout: 300s

# ============================================
# Makefile 生成配置
# ============================================
makefile:
  # 自定义 Make targets
  custom_targets:
  - name: test
    description: "Run tests"
    commands:
    - go test -v ./...

  - name: lint
    description: "Run linter"
    commands:
    - golangci-lint run

# ============================================
# CI/CD 路径配置（可选）
# ============================================
# 用于统一管理 CI/CD 相关脚本和配置文件的路径
# 如果不配置，将使用默认值
ci:
  # CI 脚本目录（相对于项目根目录）
  # 默认: bk-ci/tcs
  # 该目录用于存放构建脚本、部署脚本等
  script_dir: bk-ci/tcs

  # 构建配置目录（用于 K8s ConfigMap 等）
  # 默认: bk-ci/tcs/build
  # 该目录用于存放配置文件，会被挂载到容器中
  build_config_dir: bk-ci/tcs/build

# ============================================
# 元数据
# ============================================
metadata:
  template_version: "2.0.0"
  generated_at: "" # 自动填充
  generator: "tcs-gen"
